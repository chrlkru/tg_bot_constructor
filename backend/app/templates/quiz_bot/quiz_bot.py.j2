from aiogram import Bot, Dispatcher, executor, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from openpyxl import Workbook, load_workbook
from pathlib import Path
import os
from datetime import datetime

bot = Bot(token="{{ project.token }}")
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

# === FSM –¥–ª—è –æ–ø—Ä–æ—Å–∞ ===
class QuizState(StatesGroup):
    question_id = State()

# –ê–¥–º–∏–Ω-—á–∞—Ç –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ –∫–æ–º–∞–Ω–¥
ADMIN_CHAT = {{ project.content.admin_chat_id }}

# –í–æ–ø—Ä–æ—Å—ã –∏–∑ content
questions = {{ project.content.questions }}
questions_dict = {q["id"]: q for q in questions}

# –ü—É—Ç—å –∫ Excel-—Ñ–∞–π–ª—É —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
RESULTS_FILE = f"survey_results_{{ project.id }}.xlsx"

def append_results_to_excel(file_path, survey_id, user_id, answers):
    if os.path.exists(file_path):
        wb = load_workbook(file_path)
        ws = wb.active
    else:
        wb = Workbook()
        ws = wb.active
        headers = ['timestamp', 'survey_id', 'user_id'] + [f"q_{qid}" for qid in answers.keys()]
        ws.append(headers)
    row = [datetime.now().isoformat(), survey_id, user_id] + list(answers.values())
    ws.append(row)
    wb.save(file_path)

async def send_results_to_admin(user_id, answers):
    # –ø–æ–ª—É—á–∞–µ–º username –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º ID
    chat = await bot.get_chat(user_id)
    name = f"@{chat.username}" if chat.username else str(user_id)
    text = f"üìã –ù–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–ø—Ä–æ—Å–∞\n\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {name}\n\n"
    for idx, (qid, ans) in enumerate(answers.items(), start=1):
        qtext = questions_dict[qid]["text"]
        text += f"{idx}. {qtext} ‚Äî {ans}\n"
    text += f"\n–í—Ä–µ–º—è: {datetime.now().strftime('%d.%m.%Y %H:%M')}"
    await bot.send_message(ADMIN_CHAT, text)

@dp.message_handler(commands=['start'])
async def start_quiz(message: types.Message, state: FSMContext):
    start_msg = {{ project.content.start_message }}
    if "photo" in start_msg:
        await message.answer_photo(start_msg["photo"], caption=start_msg["text"])
    elif "gif" in start_msg:
        await message.answer_animation(start_msg["gif"], caption=start_msg["text"])
    else:
        await message.answer(start_msg["text"])
    first_q = questions[0]
    await send_question(message.chat.id, first_q, state)

async def send_question(user_id, question, state: FSMContext):
    opts = question.get("options", [])
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for o in opts:
        markup.add(o)
    if "photo" in question:
        await bot.send_photo(user_id, question["photo"], caption=question["text"], reply_markup=markup)
    elif "gif" in question:
        await bot.send_animation(user_id, question["gif"], caption=question["text"], reply_markup=markup)
    else:
        await bot.send_message(user_id, question["text"], reply_markup=markup)
    await QuizState.question_id.set()
    await state.update_data(current_question_id=question["id"])

@dp.message_handler(state=QuizState.question_id)
async def handle_answer(message: types.Message, state: FSMContext):
    data = await state.get_data()
    current_qid = data.get("current_question_id")
    answers = data.get("answers", {})
    answers[current_qid] = message.text
    await state.update_data(answers=answers)

    # –≤–µ—Ç–≤–ª–µ–Ω–∏–µ –∏–ª–∏ —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
    q = questions_dict[current_qid]
    next_qid = None
    if "branches" in q:
        next_qid = q["branches"].get(message.text)
    if not next_qid:
        idx = questions.index(q)
        if idx + 1 < len(questions):
            next_qid = questions[idx + 1]["id"]

    if next_qid:
        nxt = questions_dict[next_qid]
        await send_question(message.chat.id, nxt, state)
    else:
        # –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏ —É–≤–µ–¥–æ–º–ª—è–µ–º
        answers = (await state.get_data())["answers"]
        append_results_to_excel(RESULTS_FILE, {{ project.id }}, message.from_user.id, answers)
        await send_results_to_admin(message.from_user.id, answers)
        await message.answer("–°–ø–∞—Å–∏–±–æ –∑–∞ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–ø—Ä–æ—Å–∞!", reply_markup=types.ReplyKeyboardRemove())
        await state.finish()

# === –ê–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—ã ===

@dp.message_handler(commands=['stats'])
async def send_stats(message: types.Message):
    if message.chat.id != ADMIN_CHAT:
        return
    if not os.path.exists(RESULTS_FILE):
        return await message.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")
    wb = load_workbook(RESULTS_FILE)
    ws = wb.active
    rows = list(ws.iter_rows(values_only=True))
    headers = rows[0]
    data_rows = rows[1:]
    total = len(data_rows)
    text = f"üìä –û–±–æ–±—â—ë–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –æ–ø—Ä–æ—Å—É:\n–í—Å–µ–≥–æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–π: {total}\n\n"
    for col_idx, header in enumerate(headers[3:], start=3):
        counts = {}
        for row in data_rows:
            ans = row[col_idx]
            counts[ans] = counts.get(ans, 0) + 1
        qid = int(header.split('_')[1])
        qtext = questions_dict[qid]["text"]
        text += f"{qid}. {qtext}\n"
        for ans, cnt in counts.items():
            text += f"  ‚Äî {ans}: {cnt}\n"
        text += "\n"
    await message.answer(text)

@dp.message_handler(commands=['top'])
async def send_top(message: types.Message):
    if message.chat.id != ADMIN_CHAT:
        return
    args = message.get_args().split('|')
    if len(args) != len(questions):
        return await message.answer(
            "–ù—É–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ —á–µ—Ä–µ–∑ | –≤ –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –≤–æ–ø—Ä–æ—Å–æ–≤.")
    correct = [a.strip() for a in args]
    if not os.path.exists(RESULTS_FILE):
        return await message.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.")
    wb = load_workbook(RESULTS_FILE)
    ws = wb.active
    rows = list(ws.iter_rows(values_only=True))[1:]
    best, max_correct = [], -1
    for row in rows:
        user_id = row[2]
        user_answers = list(row[3:])
        score = sum(1 for ua, ca in zip(user_answers, correct) if ua == ca)
        if score > max_correct:
            best, max_correct = [user_id], score
        elif score == max_correct:
            best.append(user_id)
    if max_correct <= 0:
        return await message.answer("–ù–∏–∫—Ç–æ –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –Ω–∏ –Ω–∞ –æ–¥–∏–Ω –≤–æ–ø—Ä–æ—Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ.")
    names = []
    for uid in set(best):
        chat = await bot.get_chat(uid)
        names.append(f"@{chat.username}" if chat.username else str(uid))
    text = f"üèÖ –õ—É—á—à–∏–µ ({max_correct} –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö):\n" + "\n".join(names)
    await message.answer(text)

@dp.message_handler(commands=['export'])
async def cmd_export_results(message: types.Message):
    if message.chat.id != ADMIN_CHAT:
        return
    file_path = Path(RESULTS_FILE)
    if not file_path.exists():
        return await message.answer("‚ùå –§–∞–π–ª —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–Ω.")
    await bot.send_document(
        ADMIN_CHAT,
        document=open(file_path, "rb"),
        caption="üì• Excel —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –æ–ø—Ä–æ—Å–∞"
    )

if __name__ == '__main__':
    executor.start_polling(dp)
