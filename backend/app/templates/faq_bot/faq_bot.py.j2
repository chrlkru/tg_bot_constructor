from aiogram import Bot, Dispatcher, executor, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
import sqlite3
from pathlib import Path

# ‚Äî –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ FSM ‚Äî
bot = Bot(token="{{ project.token }}")
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

# ‚Äî –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ‚Äî
PROJECT_ID = {{ project.id }}
ADMIN_CHAT = {{ project.content.admin_chat_id }}
DB_PATH    = Path(__file__).parent.parent / "app" / "database.db"

# ‚Äî –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã FAQ, –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç ‚Äî
def init_db():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS faq_entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            project_id INTEGER,
            question TEXT,
            answer TEXT,
            media_path TEXT
        )
    """)
    conn.commit()
    conn.close()

init_db()

# ‚Äî –†–∞–±–æ—Ç–∞ —Å –ë–î FAQ ‚Äî
def get_entries():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute(
        "SELECT id, question, answer, media_path FROM faq_entries WHERE project_id=? ORDER BY id",
        (PROJECT_ID,)
    )
    rows = cur.fetchall()
    conn.close()
    return [
        {"id": r[0], "question": r[1], "answer": r[2], "media": r[3]} for r in rows
    ]

def add_entry(question, answer, media_path):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO faq_entries (project_id,question,answer,media_path) VALUES (?,?,?,?)",
        (PROJECT_ID, question, answer, media_path or "")
    )
    conn.commit()
    eid = cur.lastrowid
    conn.close()
    return eid

def delete_entry(entry_id):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute(
        "DELETE FROM faq_entries WHERE project_id=? AND id=?",
        (PROJECT_ID, entry_id)
    )
    conn.commit()
    conn.close()

# ‚Äî FSM-—Å–æ—Å—Ç–æ—è–Ω–∏—è ‚Äî
class FAQState(StatesGroup):
    waiting_for_choice = State()

class AdminAddFAQ(StatesGroup):
    waiting_for_question = State()
    waiting_for_answer   = State()
    waiting_for_media    = State()

class AdminDelFAQ(StatesGroup):
    waiting_for_selection = State()
    waiting_for_confirm   = State()

# ‚Äî –£—Ç–∏–ª–∏—Ç–∞: —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –≤–æ–ø—Ä–æ—Å–æ–≤ ‚Äî
def format_questions(entries):
    text = "üìñ FAQ ‚Äî –°–ø–∏—Å–æ–∫ –≤–æ–ø—Ä–æ—Å–æ–≤:\n\n"
    for idx, e in enumerate(entries, start=1):
        text += f"{idx}. {e['question']}\n"
    text += "\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¥–ª—è –æ—Ç–≤–µ—Ç–∞."
    return text

# === –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Ä–µ–∂–∏–º ===

@dp.message_handler(lambda m: m.chat.id != ADMIN_CHAT, commands=['start','faq'])
async def cmd_faq(message: types.Message):
    entries = get_entries()
    if not entries:
        return await message.answer("‚ùå –í FAQ –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π.")
    await message.answer(
        format_questions(entries),
        reply_markup=types.ReplyKeyboardRemove()
    )
    await FAQState.waiting_for_choice.set()

@dp.message_handler(lambda m: m.chat.id != ADMIN_CHAT, state=FAQState.waiting_for_choice)
async def process_choice(message: types.Message, state: FSMContext):
    text = message.text.strip().lower()
    # –ø–æ–≤—Ç–æ—Ä —Å–ø–∏—Å–∫–∞
    if text in ['—Å–ø–∏—Å–æ–∫','—Å–ø–∏—Å–æ–∫ –≤–æ–ø—Ä–æ—Å–æ–≤']:
        return await message.answer(format_questions(get_entries()))
    # –Ω–æ–º–µ—Ä
    if not text.isdigit():
        return await message.answer("‚ùó –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞.")
    idx = int(text)
    entries = get_entries()
    if idx < 1 or idx > len(entries):
        return await message.answer("‚ùó –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä.")
    e = entries[idx-1]
    # –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ –∏ –º–µ–¥–∏–∞
    if e['media']:
        path = Path(__file__).parent.parent / "media" / str(PROJECT_ID) / e['media']
        if path.exists():
            await bot.send_photo(message.chat.id, open(path,'rb'), caption=e['answer'])
        else:
            await message.answer(e['answer'])
    else:
        await message.answer(e['answer'])
    # –∫–Ω–æ–ø–∫–∞ ¬´–°–ø–∏—Å–æ–∫ –≤–æ–ø—Ä–æ—Å–æ–≤¬ª
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    kb.add("–°–ø–∏—Å–æ–∫ –≤–æ–ø—Ä–æ—Å–æ–≤")
    await message.answer(
        "–ß—Ç–æ–±—ã —Å–Ω–æ–≤–∞ —É–≤–∏–¥–µ—Ç—å —Å–ø–∏—Å–æ–∫, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É.",
        reply_markup=kb
    )
    await state.finish()

# === –ê–¥–º–∏–Ω: –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å ===

@dp.message_handler(lambda m: m.chat.id == ADMIN_CHAT, commands=['addfaq'])
async def cmd_addfaq(msg: types.Message):
    await msg.answer("üÜï –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç **–≤–æ–ø—Ä–æ—Å–∞**:")
    await AdminAddFAQ.waiting_for_question.set()

@dp.message_handler(state=AdminAddFAQ.waiting_for_question, lambda m: m.chat.id == ADMIN_CHAT)
async def faq_q(msg: types.Message, state: FSMContext):
    q = msg.text.strip()
    if not q:
        await msg.answer("‚ùó –í–æ–ø—Ä–æ—Å –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –û—Ç–º–µ–Ω–∞.")
        return await state.finish()
    await state.update_data(question=q)
    await msg.answer("‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç **–æ—Ç–≤–µ—Ç–∞**:")
    await AdminAddFAQ.waiting_for_answer.set()

@dp.message_handler(state=AdminAddFAQ.waiting_for_answer, lambda m: m.chat.id == ADMIN_CHAT)
async def faq_a(msg: types.Message, state: FSMContext):
    a = msg.text.strip()
    if not a:
        await msg.answer("‚ùó –û—Ç–≤–µ—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –û—Ç–º–µ–Ω–∞.")
        return await state.finish()
    await state.update_data(answer=a)
    await msg.answer("üì∑ –ü—Ä–∏–∫—Ä–µ–ø–∏—Ç–µ —Ñ–∞–π–ª –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ ¬´–Ω–µ—Ç¬ª:")
    await AdminAddFAQ.waiting_for_media.set()

@dp.message_handler(state=AdminAddFAQ.waiting_for_media, content_types=types.ContentTypes.ANY,
                    lambda m: m.chat.id == ADMIN_CHAT)
async def faq_m(msg: types.Message, state: FSMContext):
    data = await state.get_data()
    media = ""
    if msg.content_type in ['photo','document']:
        saved = await msg.document.download(destination_dir=f"media/{PROJECT_ID}")
        media = saved.name
    elif msg.text.strip().lower() != '–Ω–µ—Ç':
        await msg.answer("‚ùó –ù—É–∂–Ω–æ —Ñ–∞–π–ª –∏–ª–∏ ¬´–Ω–µ—Ç¬ª. –û—Ç–º–µ–Ω–∞.")
        return await state.finish()
    eid = add_entry(data['question'], data['answer'], media)
    await msg.answer(f"‚úÖ FAQ #{eid} –¥–æ–±–∞–≤–ª–µ–Ω.")
    await state.finish()

# === –ê–¥–º–∏–Ω: —É–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å ===

@dp.message_handler(lambda m: m.chat.id == ADMIN_CHAT, commands=['delfaq'])
async def cmd_delfaq(msg: types.Message):
    entries = get_entries()
    if not entries:
        return await msg.answer("‚ùå FAQ –ø—É—Å—Ç.")
    await msg.answer(format_questions(entries))
    await msg.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä FAQ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:")
    await AdminDelFAQ.waiting_for_selection.set()

@dp.message_handler(state=AdminDelFAQ.waiting_for_selection, lambda m: m.chat.id == ADMIN_CHAT)
async def faq_del_select(msg: types.Message, state: FSMContext):
    text = msg.text.strip()
    if not text.isdigit():
        return await msg.answer("‚ùó –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä.")
    idx = int(text)
    entries = get_entries()
    if idx < 1 or idx > len(entries):
        return await msg.answer("‚ùó –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä.")
    e = entries[idx-1]
    await state.update_data(del_id=e['id'])
    kb = types.InlineKeyboardMarkup().add(
        types.InlineKeyboardButton("‚úÖ –î–∞", callback_data="del_confirm"),
        types.InlineKeyboardButton("‚ùå –ù–µ—Ç", callback_data="del_cancel")
    )
    await msg.answer(f"–£–¥–∞–ª–∏—Ç—å #{e['id']} ¬´{e['question']}¬ª?", reply_markup=kb)
    await AdminDelFAQ.waiting_for_confirm.set()

@dp.callback_query_handler(lambda c: c.data in ['del_confirm','del_cancel'],
                           state=AdminDelFAQ.waiting_for_confirm)
async def faq_del_confirm(c: types.CallbackQuery, state: FSMContext):
    if c.data == 'del_confirm':
        eid = (await state.get_data())['del_id']
        delete_entry(eid)
        await c.message.edit_text(f"‚úÖ FAQ #{eid} —É–¥–∞–ª—ë–Ω.")
    else:
        await c.message.edit_text("‚ùå –£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    await state.finish()
    await c.answer()

if __name__ == '__main__':
    executor.start_polling(dp)
